<title>ðŸŒŠ teleportation at home</title>
<style>body{font-size:0.95rem;font-family:Lucida Console,Lucida Sans Typewriter,monaco,Bitstream Vera Sans Mono,monospace;}h5{margin-top:5px;margin-bottom:5px;}@media(min-width:768px){.post{max-width:90%;margin:auto;}}@media(min-width:992px){.post{max-width:80%;margin:auto;}}@media(min-width:1200px){.post{max-width:65%;margin:auto;}}</style>
<center><h5><a href="/index.html">home</a> | <a href="/about.html">about</a></h5></center>
<hr>
<div class="post">
  <h3>teleportation at home</h3>
  <h5>jul. 26, 2019</h5>
  <br>
  we now live in an age where that title is a real, meaningful statement; you can--right now--transfer information from one place to another without actually moving it.<br>
  the black magic that allows this to happen is quantum mechanics, and the new generation of machine built on its laws.<br>
  <br>
  in may 2016, IBM released the <a href="https://quantum-computing.ibm.com/">Q Experience</a>, a cloud-based quantum computing platform that was open to the public, but required a background in linear algebra to use and understand. about a year later, they released <a href="https://qiskit.org/">Qiskit</a>, an open-source quantum development framework that was high-level and well-documented enough that it significantly lowered the barrier to entry for writing quantum programs, no longer requiring that the author have a significant math background to understand what they were doing. this is great because i am both bad at math and lacking any background in linear algebra, but i can still give you a fly-over view of quantum computing and the process of implementing a teleportation algorithm using quantum logic gates. i've embedded links throughout the text to pages that explain more about what you're reading, if you're curious. first, let's start with what makes a computer "quantum".<br>
  <h4>quantum vs. classical computing</h4>
  as you know, classical computers--the computers you interact with in your day-to-day life--operate using a binary system of 1's and 0's. applying a higher voltage to a transistor turns a bit on (1), and a lower voltage turns it off (0). this system of boolean logic is based on a fundamental feature of the laws of (classical) physics: something is or it isn't. this is not the case in the quantum world because of a principle called <a href="https://en.wikipedia.org/wiki/Quantum_superposition">superposition</a>, which allows a particle to be in two different states at the same time. this leads to one of the most important features of quantum mechanics to remember: <b>unlike classical systems which have defined and predictable states, quantum systems have states that exist as probabilities <i>until they are measured</i></b>. taking a measurement--in other words, observing it--causes the system to <i>randomly</i> collapse into only one state, a process called <a href="https://en.wikipedia.org/wiki/Quantum_decoherence">decoherence</a>. this is how information is transferred from quantum computers, which use <a href="https://en.wikipedia.org/wiki/Qubit">qubits</a>, to classical computers which use bits<a href="#1"><sup>1</sup></a>.<br>
  <br>
  a second principle fundamental to quantum computing is <a href="https://en.wikipedia.org/wiki/Quantum_entanglement">entanglement</a>, an essential component for our quantum teleportation program. after <a href="https://en.wikipedia.org/wiki/Quantum_entanglement#Methods_of_creating_entanglement">generating</a> two entangled particles--say, electrons Î± and Î²--some of their properties will be connected such that <b>the state of one electron cannot be fully described without knowing the state of the other</b>. this is the point where things get, as Einstein wrote, <a href="https://phys.org/news/2015-11-nist-team-spooky-action-distance.html">spooky</a>.<br>
  <br>
  recall from two paragraphs ago that quantum states exist as probabilities until they are measured, which randomly collapses them into a discrete state. let's say we generated electrons Î± and Î² so that their combined <a href="https://en.wikipedia.org/wiki/Spin_(physics)">spin</a> is 0, and let's say we measure the spin of electron Î± along the x-axis and get +1. if we measured it a million more times we might get a distribution like `{ +1: 438287, -1: 561713 }`, or <a href="https://en.wikipedia.org/wiki/Quantum_error_correction">nearly</a> a 50% chance of observing either spin. now let's take the same measurement on electron Î± and electron Î², the same amount of times. we might get a distribution like `[ Î±: { +1: 523098 , -1: 476902 }, Î²: { +1: 480902, -1: 519098} ]`. notice that they are still nearly equally distributed, but the phenomenon of entanglement has now become apparent: the measured states are (nearly) perfectly inversely correlated. measuring--and therefore collapsing--electron Î± has caused electron Î² to collapse with the opposite state every time it was measured.<br>
  <br>
  this is a little weird, but we could imagine an explanation that is possible within the bounds of classical physics. we know they are not deciding beforehand which state to collapse into because the distribution of measured states is random, but are they are somehow communicating their states to each other <i>extremely</i> quickly before they collapse? are they making the decision based on some factor in their shared environment? nope, sorry, it's the spooky black magic of quantum mechanics, and here's how you know: if you separate the two particles, let's say 1 light-year apart, and perform the same experiment, <i>you will get the same result</i>. there is no explanation for this phenomenon within classical physics because it dictates that it is impossible for two particles to communicate instantaneously over a distance of 5878625000000 miles. this phenomenon is called <a href="https://en.wikipedia.org/wiki/Quantum_teleportation">quantum teleportation</a>, and it's <i><b>wild</b></i>.<br>
  <br>
  that was an extremely high-level, fly-over view of some of the features of quantum mechanics that have applications to computers, but i highly recommend reading about these phenomena in more detail because they're <i>incredibly</i> strange. you will get more out of it more quickly if you have a background in linear algebra, but you can also just try to brute force your way through it like me! but with that covered, we can start to apply it on a real quantum computer. i'll cover the individual steps and what they mean even if you don't feel like following along yourself.<br>
  <h4>designing a quantum circuit</h4>
  the first step is to <a href="https://quantum-computing.ibm.com/">make a Q Experience account</a>. it will prompt you to log in instead of register, but logging in through Google will let you to create an IBM account. when you finish your registration and log in, you'll see a dashboard. on the right panel, there's a list of the quantum computers and simulators you have access to. the icons on the left sidebar are your navigation buttons. you have this dashboard, your job results, a circuit composer, Qiskit notebooks, and a link to the docs (i spent a lot of time here). i highly recommend that you check out the notebooks because they include some really good tutorials to get you up to speed, since we're going to jump straight in to making circuits. go to the circuit composer and click "create circuit". click on the `</>` icon on the left side of the composer to show a representation of the circuit in `qasm`, or <a href="https://arxiv.org/pdf/1707.03429.pdf">quantum assembly language</a>.
  to maintain the scope of this post we are only going to discuss the three operators that are necessary for our quantum teleportation program: the Hadamard transform, the CNOT gate, and the measurement operator, respectively.<br>
  <br>
  the function of the <a href="https://en.wikipedia.org/wiki/Hadamard_transform#Quantum_computing_applications">Hadamard transform</a> is to put a qubit into superposition<a href="#2"><sup>2</sup></a>, which has the practical consequence of putting it into a quantum state that no longer has a discrete value but a _distribution of probabilities_ of values. this is often described as analogous to flipping a coin, because in mid-flip, the coin is both heads and tails and takes a discrete, random state when it lands. similarly, measuring the qubit at this point will randomly give one of its possible states.<br>
  <br>
  the <a href="https://en.wikipedia.org/wiki/Controlled_NOT_gate">CNOT gate</a> stands for "controlled NOT", and combines the functions of the classical <a href="https://en.wikipedia.org/wiki/Inverter_(logic_gate)">NOT gate</a>, which simply negates a value, and <a href="https://en.wikipedia.org/wiki/XOR_gate">XOR</a> gate, which produces 1 if either of the values are 1 but not both. the CNOT gate's purpose is to entangle<a href='#3'><sup>3</sup></a> two qubits and operates by flipping the second qubit <a href="https://en.wikipedia.org/wiki/If_and_only_if">iff</a> the first qubit is 1.<br>
  <br>
  the measurement operator is self-explanatory; it measures and collapses a qubit, storing the state it gives in a classical bit.<br>
  <br>
  in the composer we have 5 qubits automatically initialized to 0 (but we will only be using the first 2) and a classical bit at the bottom to read out to. first, put the qubits into superposition by applying the Hadamard transform on the first qubit<a href="#4"><sup>4</sup></a>. do this by dragging the `H` button onto the first slot of the top qubit. next, entangle the qubits by dragging the blue `+` (a CNOT gate) onto the second slot, which will apply it across qubits 0 and 1. finally, we can measure both qubits and store the result in a classical bit by dragging the measurement operator onto both qubits, one at a time. now we have our complete quantum circuit!<br>
  <br>
  click "run" at the top right and select a backend. `ibm_qasm_simulator` is, as labelled, a classical simulation of how a small quantum computer would work. select one of the other options to run your algorithm on a <a href="https://www.research.ibm.com/ibm-q/technology/devices/">real quantum computer</a>. the "shots" parameter sets the number of times the computer will run the algorithm, returning a distribution of results. this is a mitigation strategy for quantum noise which is responsible for producing errors and inaccurate results. leave it set to 1024 and click "run".<br>
  <br>
  your job will be added to the "pending results" list as it waits for the quantum computer you selected to become available, which could take a few minutes. click the link added to the "results" list when it completes. you may see a "transpiled"<a href='#5'><sup>5</sup></a> version of your circuit, your original circuit, and your results at the bottom. but before we check what they are, what is our experimental hypothesis? in other words, what do we expect? we have two qubits--initialized to a state of 0--on which we performed these actions: first, we put them into superposition with the Hadamard transform so they would give a random result when their state was measured. then, we entangled them with the CNOT gate so that measuring one qubit caused its paired qubit to give a perfectly correlated state (excluding noise-induced error), so we predict that qubit 0 will give a random distribution of results, and that qubit 1's results will be nearly perfectly correlated. now let's verify our prediction.<br>
  <br>
  first, ignore the results with significantly lower probabilities; these are errors resulting from the quantum noise mentioned earlier, and the reason we ran this algorithm many times. second, ignore all but the final two bits of the results (i.e., interpret 00000000000011 as 11). of the two remaining bits, the left bit corresponds to qubit 0, and the right to qubit 1. we're left with a ~50% 00 and ~50% 11 result, which is exactly what we predicted!<br>
  <br>
  you might be wondering, "wait a minute, earlier you told me that measuring an entangled qubit would make the other give the <i>opposite</i> value. so why are these qubits the same?" the answer is that the earlier example is a very specific case where the two entangled electrons were generated so that their total spin was 0, so both spins must add to 0 (e.g., be opposite). but to further understand how qubit 1 is being correlated with 0, think about the CNOT gate again. it takes in two qubits--a control and target qubit--and inverts the value of the target iff the control is 1. also remember that both qubits are initialized to 0. so if we measure the control and get 1, the CNOT gate will change the target to 1. if the control produces 0, nothing changes, and the target remains 0.<br>
  <br>
  something else i want to clarify is the qualification i made at the beginning of this post: that we were implementing our program using <b>quantum logic gates</b>. this is an important distinction with implications that would take another article to summarize, but in short, it's a way of summarizing what's physically happening inside the quantum computer when you tell it to do things. if you try, you'll find that it's extremely difficult to get a straight answer about this on the internet, and part of the reason for that is because it requires a lot of heavy math to explain and is totally different between  different types of quantum computers. the <a href="https://quantumcomputing.stackexchange.com/questions/tagged/physical-realization">"physical-realization"</a> tag of the quantum computing stack exchange website has some answers that go into the gritty details about this, if you're curious and have the math background for it. but to give an oversimplified answer, IBM's public-facing quantum computers use quantum logic gates, which are basically standardized operations--like steps in a recipe--that can be chained together and executed on the computer's existing qubits, rather than having to generate new pairs of entangled particles every time we want to run a program. IBM's quantum computers have physical implementations of a <a href="https://arxiv.org/pdf/1804.03719.pdf">limited number of quantum logic gates</a> that perform these operations in the real world. it is by chaining these gates together that quantum algorithms are written, which make up a quantum program.<br>
  <br>
  Richard Feynman--one the greatest physicists to have ever lived--quipped, "i think i can safely say that nobody understands quantum mechanics." it's an extremely difficult concept to wrap your head around, not just because it's something we simply don't have any quotidian experience to understand it through. so don't be discouraged if you find yourself banging your head against something like entanglement! if you "get it" to the point where you can explain it to someone else, and field their questions, i'd say you're at the top of your game. that's a big reason why i wrote this: to "get it" to the point where i could explain it to you! if you happen to be a quantum physicist, i would love for you to email me and explain what i should have said differently.<br>
  <br>
  as Pascal wrote, i have made this longer than usual because i have not had time to make it shorter, but i hope that you've learned something interesting (if not useful), and that i've pointed you to some really fascinating reading. i haven't even touched on quantum mechanics' applications to <a href="https://en.wikipedia.org/wiki/Quantum_biology">biology</a>, <a href="https://en.wikipedia.org/wiki/Quantum_chemistry">chemistry</a>, <a href="https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Wigner_interpretation"><b><i>consciousness(!!)</i></b></a>, and many other fields, not to mention the <a href="https://en.wikipedia.org/wiki/Timeline_of_quantum_mechanics">fascinating experiments</a> that have been conducted to demonstrate the strangeness of the quantum world. i strongly encourage you to wander around IBM's very well-written <a href="https://quantum-computing.ibm.com/support">documentation</a> if you have the time.<br>
  <br>
  <hr>
  <h4>footnotes</h4>
  <span id="1">1</span>: you could call the action of transferring quantum information to classical bits the "rate-limiting" step of quantum phenomena like teleportation; the information itself can be transported instantaneously, but reading out the information is limited by the speed of light. this is called the <a href="https://en.wikipedia.org/wiki/No-communication_theorem">"no-communication theorem"</a>. this is extremely important because if it were not the case, you could have situations where information is being read at the destination *before it has actually left*. let that one bake your noodle. to get a better grasp of qubits, <a href="https://quantum-computing.ibm.com/support/guides/introduction-to-quantum-circuits">this tutorial</a> from IBM is really well-written and easy to follow.<br>
  <br>
  <span id="2">2</span>: <a href="https://github.com/Qiskit/ibmqx-user-guides/blob/master/rst/beginners-guide/005-Single-Qubit_Gates/002-Creating_superposition.rst">this documentation article</a> does a good job of explaining how this works.<br>
  <br>
  <span id="3">3</span>: if you, like me, want to see proof you're running this on a system with qubits that are actually entangled and not just a simulator, <a href="https://www.nature.com/articles/s41534-018-0095-x">this article</a> in Nature explains the architecture of their 16-qubit quantum computer.<br>
  <br>
  <span id="4">4</span>: you may be wondering why the Hadamard transform is not applied to both qubits in order to put both into superposition, which is a great question! however, that is beyond the scope of this post because you need to dip into linear algebra to explain why that is not the case. <a href="https://cs.stackexchange.com/questions/57977/hadamard-gate-on-entangled-qubit">this stack exchange question</a> has some useful answers and comments.<br>
  <br>
  <span id="5">5</span>: "transpiled" is a portmanteau of "translated" and "compiled" because it effectively converts a program into a different one that produces the same result. this is usually done to optimize the program or run it on a system where the original is not supported. the IBM system will sometimes transpile your circuit by combining and replacing gates to optimize it while preserving the original effect.<br>
</div>
<br>
<hr>
<center><h5>matt@{this domain} / (0) 2019 no rights reserved</h5></center>
